%name IVProg;

%defs (
  structure A = Ast
);

%tokens
  : KW_bloco ("bloco")
  | KW_if ("se") | KW_else ("senao")
  | CON_int of Int.int | CON_string of string
  | ID of string | RELATIONAL_OP of string
  | ARITHMETIC_OP of string | BI_BOOLEAN_OP of string | UN_BOOLEAN_OP of string
  | LP ("(") | RP (")") | SEMI (";")
  | LC ("{") | RC ("}")
  | KW_while ("enquanto") 
  | KW_for ("para") | KW_from ("de") | KW_until ("ate")
  ;

%start exp;

exp
  : %try blockExp SEMI expsequence => ( A.Sequence(blockExp :: expsequence) )
  | %try blockExp
  ;

expsequence
  : %try blockExp SEMI expsequence => ( blockExp :: expsequence )
  | %try blockExp => ( [blockExp] )
  ;

blockExp
  : KW_if opExp LC opExp KW_else opExp => ( A.IfThenElse(opExp1, opExp2, opExp3) )
  | opExp
  ;

opExp
  : %try appExps OP opExp => ( A.InfixApp(appExps, OP, opExp) )
  | %try appExps
  ;

appExps
  : simpleExp+ =>
    (
      let
        fun apps(result, nil) = result
          | apps(result, hd :: tl) = A.App(apps(hd, tl), result)

        val simpleExpRev = List.rev simpleExp
      in
        apps(List.hd simpleExpRev, List.tl simpleExpRev)
      end
    )
  ;

simpleExp
  : CON_int => ( A.IntConstant(CON_int) )
  | CON_string => ( A.StringConstant(CON_string) )
  | ID => ( A.Variable(ref (A.create_symbol ID)) )
  | %try LP exp RP => ( exp )
  | LP RP => ( A.Unit )
  ;

explist
  : %try exp => ( [exp] )
  ;

fnArgs
  : LP RP => ( [] )
  | LP arglist RP => ( arglist )
  | ID => ( [A.Name(ref (A.create_symbol ID))] )
  ;

arglist
  : %try ID => ( [A.Name(ref (A.create_symbol ID))] )
  ;

valdec
  : ID OP exp %where ( OP = "=" ) => ( A.Valdec(A.Name(ref (A.create_symbol ID)), false, exp) )
  ;

fundec
  : ID fnArgs OP exp %where ( OP = "=" ) => ( A.Valdec(A.Name(ref (A.create_symbol ID)), true, A.Fn(fnArgs, exp)) )
  ;
